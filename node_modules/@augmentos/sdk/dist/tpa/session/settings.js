"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SettingsManager = void 0;
/**
 * ğŸ”§ Settings Manager Module
 *
 * Manages TPA settings with automatic synchronization and change notifications.
 * Provides type-safe access to settings with default values.
 */
const events_1 = __importDefault(require("events"));
const api_client_1 = require("./api-client");
/**
 * Internal event names
 */
var SettingsEvents;
(function (SettingsEvents) {
    SettingsEvents["CHANGE"] = "settings:change";
    SettingsEvents["VALUE_CHANGE"] = "settings:value:";
})(SettingsEvents || (SettingsEvents = {}));
/**
 * ğŸ”§ Settings Manager
 *
 * Provides a type-safe interface for accessing and reacting to TPA settings.
 * Automatically synchronizes with AugmentOS Cloud.
 */
class SettingsManager {
    /**
     * Create a new settings manager
     *
     * @param initialSettings Initial settings values (if available)
     * @param packageName Package name for the TPA
     * @param wsUrl WebSocket URL (for deriving HTTP API URL)
     * @param userId User ID (for authenticated requests)
     */
    constructor(initialSettings = [], packageName, wsUrl, userId) {
        // Current settings values
        this.settings = [];
        // Event emitter for change notifications
        this.emitter = new events_1.default();
        this.settings = [...initialSettings];
        // Create API client if we have enough information
        if (packageName) {
            this.apiClient = new api_client_1.ApiClient(packageName, wsUrl, userId);
        }
    }
    /**
     * Configure the API client
     *
     * @param packageName Package name for the TPA
     * @param wsUrl WebSocket URL
     * @param userId User ID
     */
    configureApiClient(packageName, wsUrl, userId) {
        if (!this.apiClient) {
            this.apiClient = new api_client_1.ApiClient(packageName, wsUrl, userId);
        }
        else {
            this.apiClient.setWebSocketUrl(wsUrl);
            this.apiClient.setUserId(userId);
        }
    }
    /**
     * Update the current settings
     * This is called internally when settings are loaded or changed
     *
     * @param newSettings New settings values
     * @returns Map of changed settings
     */
    updateSettings(newSettings) {
        const changes = {};
        // Copy the new settings
        const updatedSettings = [...newSettings];
        // Detect changes comparing old and new settings
        for (const newSetting of updatedSettings) {
            const oldSetting = this.settings.find(s => s.key === newSetting.key);
            // Skip if value hasn't changed
            if (oldSetting && this.areEqual(oldSetting.value, newSetting.value)) {
                continue;
            }
            // Record change
            changes[newSetting.key] = {
                oldValue: oldSetting?.value,
                newValue: newSetting.value
            };
        }
        // Check for removed settings
        for (const oldSetting of this.settings) {
            const stillExists = updatedSettings.some(s => s.key === oldSetting.key);
            if (!stillExists) {
                changes[oldSetting.key] = {
                    oldValue: oldSetting.value,
                    newValue: undefined
                };
            }
        }
        // If there are changes, update the settings and emit events
        if (Object.keys(changes).length > 0) {
            this.settings = updatedSettings;
            this.emitChanges(changes);
        }
        return changes;
    }
    /**
     * Check if two setting values are equal
     *
     * @param a First value
     * @param b Second value
     * @returns True if the values are equal
     */
    areEqual(a, b) {
        // Simple equality check - for objects, this won't do a deep equality check
        // but for most setting values (strings, numbers, booleans) it works
        return a === b;
    }
    /**
     * Emit change events for updated settings
     *
     * @param changes Map of changed settings
     */
    emitChanges(changes) {
        // Emit the general change event
        this.emitter.emit(SettingsEvents.CHANGE, changes);
        // Emit individual value change events
        for (const [key, change] of Object.entries(changes)) {
            this.emitter.emit(`${SettingsEvents.VALUE_CHANGE}${key}`, change.newValue, change.oldValue);
        }
    }
    /**
     * ğŸ”„ Listen for changes to any setting
     *
     * @param handler Function to call when settings change
     * @returns Function to remove the listener
     *
     * @example
     * ```typescript
     * settings.onChange((changes) => {
     *   console.log('Settings changed:', changes);
     * });
     * ```
     */
    onChange(handler) {
        this.emitter.on(SettingsEvents.CHANGE, handler);
        return () => this.emitter.off(SettingsEvents.CHANGE, handler);
    }
    /**
     * ğŸ”„ Listen for changes to a specific setting
     *
     * @param key Setting key to monitor
     * @param handler Function to call when the setting changes
     * @returns Function to remove the listener
     *
     * @example
     * ```typescript
     * settings.onValueChange('transcribe_language', (newValue, oldValue) => {
     *   console.log(`Language changed from ${oldValue} to ${newValue}`);
     * });
     * ```
     */
    onValueChange(key, handler) {
        const eventName = `${SettingsEvents.VALUE_CHANGE}${key}`;
        this.emitter.on(eventName, handler);
        return () => this.emitter.off(eventName, handler);
    }
    /**
     * ğŸ” Check if a setting exists
     *
     * @param key Setting key to check
     * @returns True if the setting exists
     */
    has(key) {
        return this.settings.some(s => s.key === key);
    }
    /**
     * ğŸ” Get all settings
     *
     * @returns Copy of all settings
     */
    getAll() {
        return [...this.settings];
    }
    /**
     * ğŸ” Get a setting value with type safety
     *
     * @param key Setting key to get
     * @param defaultValue Default value if setting doesn't exist or is undefined
     * @returns Setting value or default value
     *
     * @example
     * ```typescript
     * const lineWidth = settings.get<number>('line_width', 30);
     * const language = settings.get<string>('transcribe_language', 'English');
     * ```
     */
    get(key, defaultValue) {
        const setting = this.settings.find(s => s.key === key);
        if (setting && setting.value !== undefined) {
            return setting.value;
        }
        return defaultValue;
    }
    /**
     * ğŸ” Find a setting by key
     *
     * @param key Setting key to find
     * @returns Setting object or undefined
     */
    getSetting(key) {
        return this.settings.find(s => s.key === key);
    }
    /**
     * ğŸ”„ Fetch settings from the cloud
     * This is generally not needed since settings are automatically kept in sync,
     * but can be used to force a refresh if needed.
     *
     * @returns Promise that resolves to the updated settings
     * @throws Error if the API client is not configured or the request fails
     */
    async fetch() {
        if (!this.apiClient) {
            throw new Error('Settings API client is not configured');
        }
        try {
            const newSettings = await this.apiClient.fetchSettings();
            this.updateSettings(newSettings);
            return this.settings;
        }
        catch (error) {
            console.error('Error fetching settings:', error);
            throw error;
        }
    }
}
exports.SettingsManager = SettingsManager;
